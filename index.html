<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Otomanopee+One&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/style.css">
    <title>Techademy</title>
</head>
<body>
    <header id="header-titlebar">
        <nav id="header-nav">
            <h1 id="header-title">Techademy</h1>
            <ul>
                <li><a href="#about-us">About Us</a></li>
                <li><a href="#contact">Contact</a></li>
                <li><a href="#home">Home</a></li>
            </ul>
        </nav>
    </header>

    <nav id="navbar">
        <header id="navbar-header">Python Documentation</header>

            <ul>
                <li><a class="nav-link" href="#The_Python_Tutorial">The Python Tutorial</a></li>

                <li><a class="nav-link" href="#1._An_Informal_Introduction_to_Python">1. An Informal Introduction to Python</a> </li>

                <li><a class="nav-link" href="#1.1._Using_Python_as_a_Calculator">1.1. Using Python as a Calculator</a></li>

                <li><a class="nav-link" href="#1.1.1._Numbers">1.1.1. Numbers</a></li>

                <li><a class="nav-link" href="#1.1.2._Strings">1.1.2. Strings</a></li>

                <li><a class="nav-link" href="#1.1.3._Lists">1.1.3. Lists</a></li>

                <li><a class="nav-link" href="#1.2._First_Steps_Towards_Programming">1.2. First Steps Towards Programming</a></li>

                <li><a class="nav-link" href="#2._More_Control_Flow_Tools">2. More Control Flow Tools</a></li>
                <li><a class="nav-link" href="#2.1._if_Statements">2.1. if Statements</a></li>

                <li><a class="nav-link" href="#2.2._for_Statements">2.2. for Statements</a></li>

                <li><a class="nav-link" href="#2.3._The_range()_Function">2.3. The range() Function</a></li>

                <li><a class="nav-link" href="#2.4._break_and_continue_Statements,_and_else_Clauses_on_Loops">2.4. break and continue Statements, and else Clauses on Loops</a></li>


                <li><a class="nav-link" href="#2.5._pass_Statements">2.5. pass Statements</a></li>

                <li><a class="nav-link" href="#2.6._Defining_Functions">2.6. Defining Functions</a></li>
              
                
            </ul>
        </nav>
    
    <main id="main-doc">

        <section class="main-section" id="The_Python_Tutorial">
            <header>The Python Tutorial</header>

            <article>
                <p>
                    Python is an easy to learn, powerful programming language. It has efficient high-level data structures and a simple but effective approach to object-oriented programming. Python’s elegant syntax and dynamic typing, together with its interpreted nature, make it an ideal language for scripting and rapid application development in many areas on most platforms.
                </p><br>

                <p>
                    The Python interpreter and the extensive standard library are freely available in source or binary form for all major platforms from the Python Web site, <a href="https://www.python.org/" target="_blank">https://www.python.org/</a> , and may be freely distributed. The same site also contains distributions of and pointers to many free third party Python modules, programs and tools, and additional documentation.
                </p><br>

                <p>
                    The Python interpreter is easily extended with new functions and data types implemented in C or C++ (or other languages callable from C). Python is also suitable as an extension language for customizable applications.
                </p><br>

                <p>
                    This tutorial introduces the reader informally to the basic concepts and features of the Python language and system. It helps to have a Python interpreter handy for hands-on experience, but all examples are self-contained, so the tutorial can be read off-line as well.
                </p><br>

                <p>
                    For a description of standard objects and modules, see <a target="_blank" href="https://docs.python.org/3/library/index.html#library-index">The Python Standard Library.</a>  The Python Language Reference gives a more formal definition of the language. To write extensions in C or C++, read <a target="_blank" href="https://docs.python.org/3/extending/index.html#extending-index">Extending and Embedding the Python Interpreter</a>  and <a target="_blank" href="https://docs.python.org/3/c-api/index.html#c-api-index">Python/C API Reference Manual.</a>  There are also several books covering Python in depth.
                </p><br>

                <p>
                    This tutorial does not attempt to be comprehensive and cover every single feature, or even every commonly used feature. Instead, it introduces many of Python’s most noteworthy features, and will give you a good idea of the language’s flavor and style. After reading it, you will be able to read and write Python modules and programs, and you will be ready to learn more about the various Python library modules described in The Python Standard Library.
                </p><br>
            </article>
        </section>

        <section class="main-section" id="1._An_Informal_Introduction_to_Python">
            <header>1. An Informal Introduction to Python</header>

            <article>
                <p>
                    In the following examples, input and output are distinguished by the presence or absence of prompts (>>> and …): to repeat the example, you must type everything after the prompt, when the prompt appears; lines that do not begin with a prompt are output from the interpreter. Note that a secondary prompt on a line by itself in an example means you must type a blank line; this is used to end a multi-line command.
                </p><br>
                <p>
                    Many of the examples in this manual, even those entered at the interactive prompt, include comments. Comments in Python start with the hash character, #, and extend to the end of the physical line. A comment may appear at the start of a line or following whitespace or code, but not within a string literal. A hash character within a string literal is just a hash character. Since comments are to clarify code and are not interpreted by Python, they may be omitted when typing in examples.
                </p><br>
                <p>Some examples:</p><br>

                <code>
                    # this is the first comment
spam = 1  # and this is the second comment
          # ... and now a third!
text = "# This is not a comment because it's inside quotes."
                </code><br>
            </article>
        </section>

        <section class="main-section" id="1.1._Using_Python_as_a_Calculator">
            <header>1.1. Using Python as a Calculator</header>

            <article>
                <p>Let’s try some simple Python commands. Start the interpreter and wait for the primary prompt, >>>. (It shouldn’t take long.)</p><br>
            </article>

        </section>

        <section class="main-section" id="1.1.1._Numbers">
            <header>1.1.1. Numbers</header>

            <article>
                <p>
                    The interpreter acts as a simple calculator: you can type an expression at it and it will write the value. Expression syntax is straightforward: the operators +, -, * and / work just like in most other languages (for example, Pascal or C); parentheses (()) can be used for grouping. For example:
                </p>
                <code>
                    >>> 2 + 2
4
>>> 50 - 5*6
20
>>> (50 - 5*6) / 4
5.0
>>> 8 / 5  # division always returns a floating point number
1.6
                </code>
                <p>
                    The integer numbers (e.g. 2, 4, 20) have type int, the ones with a fractional part (e.g. 5.0, 1.6) have type float. We will see more about numeric types later in the tutorial.
                </p><br>
                <p>
                    Division (/) always returns a float. To do floor division and get an integer result (discarding any fractional result) you can use the // operator; to calculate the remainder you can use %:
                </p>
                <code>
                    >>> 17 / 3  # classic division returns a float
5.666666666666667
>>>
>>> 17 // 3  # floor division discards the fractional part
5
>>> 17 % 3  # the % operator returns the remainder of the division
2
>>> 5 * 3 + 2  # floored quotient * divisor + remainder
17
                </code>
                <p>
                    With Python, it is possible to use the ** operator to calculate powers 1:
                </p>
                <code>
                    >>> 5 ** 2  # 5 squared
25
>>> 2 ** 7  # 2 to the power of 7
128
                </code>
                <p>
                    The equal sign (=) is used to assign a value to a variable. Afterwards, no result is displayed before the next interactive prompt:
                </p>
                <code>
                    >>> width = 20
>>> height = 5 * 9
>>> width * height
900
                </code>
                <p>
                    If a variable is not “defined” (assigned a value), trying to use it will give you an error:
                </p>
                <code>
                    >>> n  # try to access an undefined variable
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'n' is not defined
                </code>
                <p>
                    There is full support for floating point; operators with mixed type operands convert the integer operand to floating point:
                </p>
                <code>
                    >>> 4 * 3.75 - 1
14.0
                </code>
                <p>
                    In interactive mode, the last printed expression is assigned to the variable _. This means that when you are using Python as a desk calculator, it is somewhat easier to continue calculations, for example:
                </p>
                <code>
                    >>> tax = 12.5 / 100
>>> price = 100.50
>>> price * tax
12.5625
>>> price + _
113.0625
>>> round(_, 2)
113.06
                </code>
                <p>
                    This variable should be treated as read-only by the user. Don’t explicitly assign a value to it — you would create an independent local variable with the same name masking the built-in variable with its magic behavior.
                </p><br>
                <p>
                    In addition to int and float, Python supports other types of numbers, such as Decimal and Fraction. Python also has built-in support for complex numbers, and uses the j or J suffix to indicate the imaginary part (e.g. 3+5j).
                </p><br>
            </article>

        </section>


        <section class="main-section" id="1.1.2._Strings">
            <header>1.1.2. Strings</header>

            <article>
                <p>
                    Besides numbers, Python can also manipulate strings, which can be expressed in several ways. They can be enclosed in single quotes ('...') or double quotes ("...") with the same result 2. \ can be used to escape quotes:
                </p>
                <code>
                    >>> 'spam eggs'  # single quotes
'spam eggs'
>>> 'doesn\'t'  # use \' to escape the single quote...
"doesn't"
>>> "doesn't"  # ...or use double quotes instead
"doesn't"
>>> '"Yes," they said.'
'"Yes," they said.'
>>> "\"Yes,\" they said."
'"Yes," they said.'
>>> '"Isn\'t," they said.'
'"Isn\'t," they said.'
                </code>
                <p>
                    In the interactive interpreter, the output string is enclosed in quotes and special characters are escaped with backslashes. While this might sometimes look different from the input (the enclosing quotes could change), the two strings are equivalent. The string is enclosed in double quotes if the string contains a single quote and no double quotes, otherwise it is enclosed in single quotes. The print() function produces a more readable output, by omitting the enclosing quotes and by printing escaped and special characters:
                </p>
                <code>
                    >>> '"Isn\'t," they said.'
'"Isn\'t," they said.'
>>> print('"Isn\'t," they said.')
"Isn't," they said.
>>> s = 'First line.\nSecond line.'  # \n means newline
>>> s  # without print(), \n is included in the output
'First line.\nSecond line.'
>>> print(s)  # with print(), \n produces a new line
First line.
Second line.
                </code>
                <p>
                    If you don’t want characters prefaced by \ to be interpreted as special characters, you can use raw strings by adding an r before the first quote:
                </p>
                <code>
                    >>> print('C:\some\name')  # here \n means newline!
C:\some
ame
>>> print(r'C:\some\name')  # note the r before the quote
C:\some\name
                </code>
                <p>
                    String literals can span multiple lines. One way is using triple-quotes: """...""" or '''...'''. End of lines are automatically included in the string, but it’s possible to prevent this by adding a \ at the end of the line. The following example:
                </p>
                <code>
                    print("""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
""")
                </code>
                <p>
                    produces the following output (note that the initial newline is not included):
                </p>
                <code>
                    Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
                </code>
                <p>
                    Strings can be concatenated (glued together) with the + operator, and repeated with *:
                </p>
                <code>
                    >>> # 3 times 'un', followed by 'ium'
>>> 3 * 'un' + 'ium'
'unununium'
                </code>
                <p>
                    Two or more string literals (i.e. the ones enclosed between quotes) next to each other are automatically concatenated.
                </p>
                <code>
                    >>> 'Py' 'thon'
'Python'
                </code>
                <p>
                    This feature is particularly useful when you want to break long strings:


                </p>
                <code>
                    >>> text = ('Put several strings within parentheses '
...         'to have them joined together.')
>>> text
'Put several strings within parentheses to have them joined together.'
                </code>
                <p>
                    This only works with two literals though, not with variables or expressions:
                </p>
                <code>
                    >>> prefix = 'Py'
>>> prefix 'thon'  # can't concatenate a variable and a string literal
  File "<stdin>", line 1
    prefix 'thon'
                ^
SyntaxError: invalid syntax
>>> ('un' * 3) 'ium'
  File "<stdin>", line 1
    ('un' * 3) 'ium'
                   ^
SyntaxError: invalid syntax
                </code>
                <p>If you want to concatenate variables or a variable and a literal, use +:</p>
                <code>
                    >>> prefix + 'thon'
'Python'
                </code>
                <p>
                    Strings can be indexed (subscripted), with the first character having index 0. There is no separate character type; a character is simply a string of size one:
                </p>
                <code>
                    >>> word = 'Python'
>>> word[0]  # character in position 0
'P'
>>> word[5]  # character in position 5
'n'
                </code>
                <p>
                    Indices may also be negative numbers, to start counting from the right:
                </p>
                <code>
                    >>> word[-1]  # last character
'n'
>>> word[-2]  # second-last character
'o'
>>> word[-6]
'P'
                </code>
                <p>
                    Note that since -0 is the same as 0, negative indices start from -1.
                </p><br>
                <p>
                    In addition to indexing, slicing is also supported. While indexing is used to obtain individual characters, slicing allows you to obtain substring:
                </p>
                <code>
                    >>> word[0:2]  # characters from position 0 (included) to 2 (excluded)
'Py'
>>> word[2:5]  # characters from position 2 (included) to 5 (excluded)
'tho'
                </code>
                <p>
                    Note how the start is always included, and the end always excluded. This makes sure that s[:i] + s[i:] is always equal to s:
                </p>
                <code>
                    >>> word[:2] + word[2:]
'Python'
>>> word[:4] + word[4:]
'Python'
                </code>
                <p>
                    Slice indices have useful defaults; an omitted first index defaults to zero, an omitted second index defaults to the size of the string being sliced.
                </p>
                <code>
                    >>> word[:2]   # character from the beginning to position 2 (excluded)
'Py'
>>> word[4:]   # characters from position 4 (included) to the end
'on'
>>> word[-2:]  # characters from the second-last (included) to the end
'on'
                </code>
                <p>One way to remember how slices work is to think of the indices as pointing between characters, with the left edge of the first character numbered 0. Then the right edge of the last character of a string of n characters has index n, for example:</p>
                <code>
                    +---+---+---+---+---+---+
                    | P | y | t | h | o | n |
                    +---+---+---+---+---+---+
                    0   1   2   3   4   5   6
                   -6  -5  -4  -3  -2  -1
                </code>
                <p>
                    The first row of numbers gives the position of the indices 0…6 in the string; the second row gives the corresponding negative indices. The slice from i to j consists of all characters between the edges labeled i and j, respectively.
                </p><br>
                <p>For non-negative indices, the length of a slice is the difference of the indices, if both are within bounds. For example, the length of word[1:3] is 2.
                </p><br>
                <p>
                    Attempting to use an index that is too large will result in an error:
                </p>
                <code>
                    >>> word[42]  # the word only has 6 characters
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range
                </code>
                <p>
                    However, out of range slice indexes are handled gracefully when used for slicing:
                </p>
                <code>
                    >>> word[4:42]
'on'
>>> word[42:]
''
                </code>
                <p>
                    Python strings cannot be changed — they are immutable. Therefore, assigning to an indexed position in the string results in an error:
                </p>
                <code>
                    >>> word[0] = 'J'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
>>> word[2:] = 'py'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
                </code>
                <p>
                    If you need a different string, you should create a new one:
                </p>
                <code>
                    >>> 'J' + word[1:]
'Jython'
>>> word[:2] + 'py'
'Pypy'
                </code>
                <p>
                    The built-in function len() returns the length of a string:
                </p>
                <code>
                    >>> s = 'supercalifragilisticexpialidocious'
>>> len(s)
34
                </code><br>

            </article>

        </section>

        <section class="main-section" id="1.1.3._Lists">
            <header>1.1.3. Lists</header>

            <article>
                <p>
                    Python knows a number of compound data types, used to group together other values. The most versatile is the list, which can be written as a list of comma-separated values (items) between square brackets. Lists might contain items of different types, but usually the items all have the same type.
                </p>
                <code>
                    >>> squares = [1, 4, 9, 16, 25]
>>> squares
[1, 4, 9, 16, 25]
                </code>
                <p>
                    Like strings (and all other built-in sequence types), lists can be indexed and sliced:
                </p>
                <code>
                    >>> squares[0]  # indexing returns the item
1
>>> squares[-1]
25
>>> squares[-3:]  # slicing returns a new list
[9, 16, 25]
                </code>
                <p>
                    All slice operations return a new list containing the requested elements. This means that the following slice returns a shallow copy of the list:
                </p>
                <code>
                    >>> squares[:]
[1, 4, 9, 16, 25]
                </code>
                <p>
                    Lists also support operations like concatenation:
                </p>
                <code>
                    >>> squares + [36, 49, 64, 81, 100]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
                </code>
                <p>
                    Unlike strings, which are immutable, lists are a mutable type, i.e. it is possible to change their content:
                </p>
                <code>
                    >>> cubes = [1, 8, 27, 65, 125]  # something's wrong here
>>> 4 ** 3  # the cube of 4 is 64, not 65!
64
>>> cubes[3] = 64  # replace the wrong value
>>> cubes
[1, 8, 27, 64, 125]
                </code>
                <p>
                    You can also add new items at the end of the list, by using the append() method (we will see more about methods later):
                </p>
                <code>
                    >>> cubes.append(216)  # add the cube of 6
>>> cubes.append(7 ** 3)  # and the cube of 7
>>> cubes
[1, 8, 27, 64, 125, 216, 343]
                </code>
                <p>
                    Assignment to slices is also possible, and this can even change the size of the list or clear it entirely:
                </p>
                <code>
                    >>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> letters
['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> # replace some values
>>> letters[2:5] = ['C', 'D', 'E']
>>> letters
['a', 'b', 'C', 'D', 'E', 'f', 'g']
>>> # now remove them
>>> letters[2:5] = []
>>> letters
['a', 'b', 'f', 'g']
>>> # clear the list by replacing all the elements with an empty list
>>> letters[:] = []
>>> letters
[]
                </code>
                <p>
                    The built-in function len() also applies to lists:
                </p>
                <code>
                    >>> letters = ['a', 'b', 'c', 'd']
>>> len(letters)
4
                </code>
                <p>
                    It is possible to nest lists (create lists containing other lists), for example:
                </p>
                <code>
                    >>> a = ['a', 'b', 'c']
>>> n = [1, 2, 3]
>>> x = [a, n]
>>> x
[['a', 'b', 'c'], [1, 2, 3]]
>>> x[0]
['a', 'b', 'c']
>>> x[0][1]
'b'
                </code><br>
            </article>

        </section>

        
        <section class="main-section" id="1.2._First_Steps_Towards_Programming">
            <header>1.2. First Steps Towards Programming</header>
            
            <article>
                <p>
                    Of course, we can use Python for more complicated tasks than adding two and two together. For instance, we can write an initial sub-sequence of the Fibonacci series as follows:
                </p>
                <code>
                    >>> # Fibonacci series:
... # the sum of two elements defines the next
... a, b = 0, 1
>>> while a < 10:
...     print(a)
...     a, b = b, a+b
...
0
1
1
2
3
5
8
                </code>
                <p>
                    This example introduces several new features.
                </p><br>

                <ul>
                    <li><p>The first line contains a multiple assignment: the variables a and b simultaneously get the new values 0 and 1. On the last line this is used again, demonstrating that the expressions on the right-hand side are all evaluated first before any of the assignments take place. The right-hand side expressions are evaluated from the left to the right. </p></li>
                    <li><p>The while loop executes as long as the condition (here: a < 10) remains true. In Python, like in C, any non-zero integer value is true; zero is false. The condition may also be a string or list value, in fact any sequence; anything with a non-zero length is true, empty sequences are false. The test used in the example is a simple comparison. The standard comparison operators are written the same as in C: < (less than), > (greater than), == (equal to), <= (less than or equal to), >= (greater than or equal to) and != (not equal to). </p></li>
                    <li><p>The body of the loop is indented: indentation is Python’s way of grouping statements. At the interactive prompt, you have to type a tab or space(s) for each indented line. In practice you will prepare more complicated input for Python with a text editor; all decent text editors have an auto-indent facility. When a compound statement is entered interactively, it must be followed by a blank line to indicate completion (since the parser cannot guess when you have typed the last line). Note that each line within a basic block must be indented by the same amount. </p></li>
                    <li><p>The print() function writes the value of the argument(s) it is given. It differs from just writing the expression you want to write (as we did earlier in the calculator examples) in the way it handles multiple arguments, floating point quantities, and strings. Strings are printed without quotes, and a space is inserted between items, so you can format things nicely, like this: </p><br>
                        <code>
                            >>> i = 256*256
>>> print('The value of i is', i)
The value of i is 65536
                        </code>
                        <p>
                            The keyword argument end can be used to avoid the newline after the output, or end the output with a different string:
                        </p>
                        <code>
                            >>> a, b = 0, 1
>>> while a < 1000:
...     print(a, end=',')
...     a, b = b, a+b
...
0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,
                        </code>
                    </li>
                </ul><br>
            </article>
            
        </section>

        <section class="main-section" id="2._More_Control_Flow_Tools">
            <header>2. More Control Flow Tools</header>

            <article>
                <p>
                    Besides the while statement just introduced, Python uses the usual flow control statements known from other languages, with some twists.
                </p><br>
            </article>

        </section>

        <section class="main-section" id="2.1._if_Statements">
            <header>2.1. if Statements</header>

            <article>
                <p>
                    Perhaps the most well-known statement type is the if statement. For example:
                </p>
                <code>
                    >>> x = int(input("Please enter an integer: "))
Please enter an integer: 42
>>> if x < 0:
...     x = 0
...     print('Negative changed to zero')
... elif x == 0:
...     print('Zero')
... elif x == 1:
...     print('Single')
... else:
...     print('More')
...
More
                </code>
                <p>
                    There can be zero or more elif parts, and the else part is optional. The keyword ‘elif’ is short for ‘else if’, and is useful to avoid excessive indentation. An if … elif … elif … sequence is a substitute for the switch or case statements found in other languages.
                </p><br>

            </article>

        </section>

        <section class="main-section" id="2.2._for_Statements">
            <header>2.2. for Statements</header>

            <article>
                <p>
                    The for statement in Python differs a bit from what you may be used to in C or Pascal. Rather than always iterating over an arithmetic progression of numbers (like in Pascal), or giving the user the ability to define both the iteration step and halting condition (as C), Python’s for statement iterates over the items of any sequence (a list or a string), in the order that they appear in the sequence. For example (no pun intended):
                </p>
                <code>
                    >>> # Measure some strings:
... words = ['cat', 'window', 'defenestrate']
>>> for w in words:
...     print(w, len(w))
...
cat 3
window 6
defenestrate 12
                </code>
                <p>
                    Code that modifies a collection while iterating over that same collection can be tricky to get right. Instead, it is usually more straight-forward to loop over a copy of the collection or to create a new collection:
                </p>
                <code>
                    # Strategy:  Iterate over a copy
for user, status in users.copy().items():
    if status == 'inactive':
        del users[user]

# Strategy:  Create a new collection
active_users = {}
for user, status in users.items():
    if status == 'active':
        active_users[user] = status
                </code><br>
            </article>

        </section>

        <section class="main-section" id="2.3._The_range()_Function">
            <header>2.3. The range() Function</header>

            <article>
                <p>
                    If you do need to iterate over a sequence of numbers, the built-in function range() comes in handy. It generates arithmetic progressions:
                </p>
                <code>
                    >>> for i in range(5):
...     print(i)
...
0
1
2
3
4
                </code>
                <p>
                    The given end point is never part of the generated sequence; range(10) generates 10 values, the legal indices for items of a sequence of length 10. It is possible to let the range start at another number, or to specify a different increment (even negative; sometimes this is called the ‘step’):
                </p>
                <code>
                    >>> list(range(5, 10))
[5, 6, 7, 8, 9]

>>> list(range(0, 10, 3))
[0, 3, 6, 9]

>>> list(range(-10, -100, -30))
[-10, -40, -70]
                </code>
                <p>
                    To iterate over the indices of a sequence, you can combine range() and len() as follows:
                </p>
                <code>
                    >>> a = ['Mary', 'had', 'a', 'little', 'lamb']
>>> for i in range(len(a)):
...     print(i, a[i])
...
0 Mary
1 had
2 a
3 little
4 lamb
                </code>
                <p>
                    In most such cases, however, it is convenient to use the enumerate() function, see Looping Techniques.
                </p><br>
                <p>A strange thing happens if you just print a range:</p>
                <code>
                    >>> range(10)
range(0, 10)
                </code>
                <p>In many ways the object returned by range() behaves as if it is a list, but in fact it isn’t. It is an object which returns the successive items of the desired sequence when you iterate over it, but it doesn’t really make the list, thus saving space.</p><br>
                <p>We say such an object is iterable, that is, suitable as a target for functions and constructs that expect something from which they can obtain successive items until the supply is exhausted. We have seen that the for statement is such a construct, while an example of a function that takes an iterable is sum():</p>
                <code>
                    >>> sum(range(4))  # 0 + 1 + 2 + 3
6
                </code>
                <p>Later we will see more functions that return iterables and take iterables as arguments. In chapter Data Structures, we will discuss in more detail about list().</p><br>
            </article>

        </section>

        <section class="main-section" id="2.4._break_and_continue_Statements,_and_else_Clauses_on_Loops">
            <header>2.4. break and continue Statements, and else Clauses on Loops</header>

            <article>
                <p>
                    The break statement, like in C, breaks out of the innermost enclosing for or while loop.
                </p><br>
                <p>
                    Loop statements may have an else clause; it is executed when the loop terminates through exhaustion of the iterable (with for) or when the condition becomes false (with while), but not when the loop is terminated by a break statement. This is exemplified by the following loop, which searches for prime numbers:
                </p>
                <code>
                    >>> for n in range(2, 10):
...     for x in range(2, n):
...         if n % x == 0:
...             print(n, 'equals', x, '*', n//x)
...             break
...     else:
...         # loop fell through without finding a factor
...         print(n, 'is a prime number')
...
2 is a prime number
3 is a prime number
4 equals 2 * 2
5 is a prime number
6 equals 2 * 3
7 is a prime number
8 equals 2 * 4
9 equals 3 * 3
                </code>
                <p>
                    (Yes, this is the correct code. Look closely: the else clause belongs to the for loop, not the if statement.)
                </p><br>
                <p>
                    When used with a loop, the else clause has more in common with the else clause of a try statement than it does with that of if statements: a try statement’s else clause runs when no exception occurs, and a loop’s else clause runs when no break occurs. For more on the try statement and exceptions, see Handling Exceptions.
                </p><br>
                <p>The continue statement, also borrowed from C, continues with the next iteration of the loop:</p>
                <code>
                    >>> for num in range(2, 10):
...     if num % 2 == 0:
...         print("Found an even number", num)
...         continue
...     print("Found an odd number", num)
...
Found an even number 2
Found an odd number 3
Found an even number 4
Found an odd number 5
Found an even number 6
Found an odd number 7
Found an even number 8
Found an odd number 9
                </code><br>
            </article>

        </section>

        <section class="main-section" id="2.5._pass_Statements">
            <header>2.5. pass Statements</header>

            <article>
                <p>The pass statement does nothing. It can be used when a statement is required syntactically but the program requires no action. For example:</p>
                <code>
                    >>> while True:
...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)
...
                </code>
                <p>
                    This is commonly used for creating minimal classes:
                </p>
                <code>
                    >>> class MyEmptyClass:
...     pass
...
                </code>
                <p>
                    Another place pass can be used is as a place-holder for a function or conditional body when you are working on new code, allowing you to keep thinking at a more abstract level. The pass is silently ignored:
                </p>
                <code>
                    >>> def initlog(*args):
...     pass   # Remember to implement this!
...
                </code><br>
            </article>

        </section>

        <section class="main-section" id="2.6._Defining_Functions">
            <header>2.6. Defining Functions</header>

            <article>
                <p>
                    We can create a function that writes the Fibonacci series to an arbitrary boundary:
                </p>
                <code>
                    >>> def fib(n):    # write Fibonacci series up to n
...     """Print a Fibonacci series up to n."""
...     a, b = 0, 1
...     while a < n:
...         print(a, end=' ')
...         a, b = b, a+b
...     print()
...
>>> # Now call the function we just defined:
... fib(2000)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
                </code>
                <p>
                    The keyword def introduces a function definition. It must be followed by the function name and the parenthesized list of formal parameters. The statements that form the body of the function start at the next line, and must be indented.
                </p><br>
                <p>
                    The first statement of the function body can optionally be a string literal; this string literal is the function’s documentation string, or docstring. (More about docstrings can be found in the section Documentation Strings.) There are tools which use docstrings to automatically produce online or printed documentation, or to let the user interactively browse through code; it’s good practice to include docstrings in code that you write, so make a habit of it.
                </p><br>
                <p>
                    The execution of a function introduces a new symbol table used for the local variables of the function. More precisely, all variable assignments in a function store the value in the local symbol table; whereas variable references first look in the local symbol table, then in the local symbol tables of enclosing functions, then in the global symbol table, and finally in the table of built-in names. Thus, global variables and variables of enclosing functions cannot be directly assigned a value within a function (unless, for global variables, named in a global statement, or, for variables of enclosing functions, named in a nonlocal statement), although they may be referenced.
                </p><br>
                <p>
                    The actual parameters (arguments) to a function call are introduced in the local symbol table of the called function when it is called; thus, arguments are passed using call by value (where the value is always an object reference, not the value of the object). 1 When a function calls another function, or calls itself recursively, a new local symbol table is created for that call.
                </p><br>
                <p>
                    A function definition associates the function name with the function object in the current symbol table. The interpreter recognizes the object pointed to by that name as a user-defined function. Other names can also point to that same function object and can also be used to access the function:
                </p>
                <code>
                    >>> fib
<function fib at 10042ed0>
>>> f = fib
>>> f(100)
0 1 1 2 3 5 8 13 21 34 55 89
                </code>
                <p>
                    Coming from other languages, you might object that fib is not a function but a procedure since it doesn’t return a value. In fact, even functions without a return statement do return a value, albeit a rather boring one. This value is called None (it’s a built-in name). Writing the value None is normally suppressed by the interpreter if it would be the only value written. You can see it if you really want to using print():
                </p>
                <code>
                    >>> fib(0)
>>> print(fib(0))
None
                </code>
                <p>
                    It is simple to write a function that returns a list of the numbers of the Fibonacci series, instead of printing it:
                </p>
                <code>
                    >>> def fib2(n):  # return Fibonacci series up to n
...     """Return a list containing the Fibonacci series up to n."""
...     result = []
...     a, b = 0, 1
...     while a < n:
...         result.append(a)    # see below
...         a, b = b, a+b
...     return result
...
>>> f100 = fib2(100)    # call it
>>> f100                # write the result
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
                </code>
                <p>This example, as usual, demonstrates some new Python features:</p>
                <ul>
                    <li><p>The return statement returns with a value from a function. return without an expression argument returns None. Falling off the end of a function also returns None.</p></li>
                    <li><p>The return statement returns with a value from a function. return without an expression argument returns None. Falling off the end of a function also returns None.</p></li>
                </ul><br>

            </article>

        </section>

        <footer>
            <div>
                <p>&copy; www.python.org. All right reserved.</p>
            </div>
        </footer>

    </main>

</body>
</html>